\chapter{Введение}

Mongrel2 --- это веб-сервер. http-запрос приходит, http-ответ уходит.
Запрос, ответ. Ничего сверхъестественного или экстраординарного в том, как
Mongrel2 работает с браузером, если не учитывать тот факт, что он поддерживает
продвинутый асинхронный протокол передачи через сокеты. Но для браузера
Mongrel2 --- это старый добрый веб-сервер с поддержкой флэш-сокетов и веб-сокетов.
Вот и всё.

Что делает Mongrel2 особенным --- это то, как он обрабатывает эти запросы ---
\emph{асинхронно и прозрачно для любого языка программирования} с использованием
простого \emph{протокола обмена сообщениями}, чтобы взимодействовать с \emph{приложениями}, а
не просто выдавать файлы. Mongrel2 также легко автоматизировать как часть вашей
инфраструктуры.

Другие серверы тоже делают что-то из перечисленного выше, но либо делают это, мягко говоря,
не самым лучшим образом, либо не всё сразу. Некоторые веб-серверы, например Jetty
и Node.js, поддерживают асинхронные операции, но ориентированы на один определённый язык
программирования\footnote{Кто захочет кодить весь день на Джаваскрипте? Ужас.}. Другие ---
позволяют писать бэкенд на любом языке, но требуют либо http-проксирование, либо FastCGI,
что не очень хорошо для асинхронности.

Mongrel2 --- единственный известный мне веб-сервер, который сфокусирован на упомянутых
вещах как едином целом.

\begin{aside}{МНОГАБУКФ}
Не хотите читать мануал? Тогда прочтите \href{http://mongrel2.org/doc/tip/docs/ru/wiki/GettingStarted.wiki}
{страничку по быстрому запуску.} На ней вы найдете
краткий список команд достаточный для того, чтобы установить и запустить сервер.
\end{aside}

\section{Языковой нейтралитет}

Термин ``языковой нейтралитет'' обозначает одну простую вещь --- для Mongrel2
все языки программирования равны; он \emph{не} отдаёт предпочтение какому-то одному из них.
Ему не важно, замешана ли ваша ``кухня'' на Питоне или вы упёртый приверженец PHP.
А быть может вы ненавидите PHP, но любите Руби и Рельсы. Без разницы. Mongrel2
знает только о запросах, ответах, асинхронных сообщениях и как их доставить в ваш бэкенд.

Это самое важное свойство сервера и рождено из желания снизить уровень языкового фанатизма
в мире. Людей интересует результат, а не то, какая технология круче или как навязать
другим свою любимую игрушку. Вместо этого Mongrel2 сосредоточен на том, чтобы
предоставить свободу в выборе того инструмента, который будет оптимальным для решения
конкретной проблемы.

\section{Асинхронность}

Многие веб-серверы асинхронны внутри, и некоторые из них вынуждают лезть в дебри их
внутреннего устройства, чтобы получить какой-то результат. Mongrel2 отличает то,
что он выносит идею асинхронности во \emph{внешний} мир. Сила этой концепции в том,
что бэкенды могут также оперировать асинхронно, используя механизм идентификации
подключённых клиентов.

Другие серверы работают по такой схеме: запрос приходит от браузера, он перенаправляется
в бэкенд, а затем бэкенд сам непосредственно шлёт ответ. Mogrel2 работает несколько иначе ---
он держит соединение с клиентом, получает запрос, отправляет запрос в бэкенд и, не блокируя,
ждёт ответ. Как только ответ полностью готов, он пересылает его назад клиенту.

Такой дизайн позволяет одинаково хорошо обрабатывать классические http-запросы, перманентные
соединения, фрагментированные ответы, флэш-сокеты и веб-сокеты.

\section{Сообщения}

Для нормальной передачи асинхронных сообщений Mongrel2 нуждался в хорошем
базовом протоколе. HTTP-проксирование делает это, но не асинхронным способом.
Поэтому Mongrel2 построен на базе ZeroMQ --- абсолютно прозрачной для языков и
транспортных механизмов системе передачи сообщений, которой \emph{не нужен}
централизованный сервер.

ZeroMQ позволяет "говорить" на любом из большого набора поддерживаемых языков
программирования, оперировать в любой сетевой архитектуре и делать это с помощью
простой коммуникационной модели и API, понятного для большинства программистов.

\section{Приложения}

Веб-серверы сегодня всё еще пишутся как-будто на дворе 1995 год и всё что должен уметь
делать сервер --- это выдавать файлы, ну, может быть, ещё графику. Сегодня веб-приложения
не выдают файлы; они реализуют бизнес-логику и делают это асинхронно. Наличие ряда
платформ\footnote{Comet, long poll, Juggernaut и т.п.}, которые пытаются реализовать
асинхронные сообщения поверх HTTP, говорит о том,
что сегодня веб-серверы должны ориентироваться на динамические приложения, а не
статические файлы.

Mongrel2 замечательно работает с файлами. Более того, код, который реализует это,
надёжен и прост для понимания. Однако Mongrel2 в первую очередь нацелен на приложения.
Быстрые, расширяемые, крутые, асинхронные или синхронные приложения, написанные на
языках, которые доступны простым смертным, такие как PHP. Если возникает дилемма
между файлами и приложениями --- приложения всегда побеждают.

\section{Автоматизация}

Философия нейтралитета к языкам программирования распространяется и на систему
конфигурирования --- вы можете использовать любой язык, чтобы настраивать
сервер.  Единственное требование --- настройки должны храниться в базе SQLite3.
Уже есть удобные инструменты, написанные на Питоне и Си, чтобы управлять этой
базой. Но если вы не питаете любви к этим языкам, то можете написать
аналогичные утилиты на своём любимом языке.

Аналогичный подход используется в почтовых серверах --- Postfix, Exim, Sendmail, qmail ---
они конвертируют конфигурационные файлы в недоделанные sql базы.
Mongrel2 успешно реализует архитектуру Модель-Вид-Контроллер в своей конфигурационной
системе. Эта архитектура весьма популярна в веб-приложениях. Роль модели выполняет
SQLite3 база, которая доступна из любого языка. Контроллер --- Mongrel2,
который считывает базу и выставляет настройки.

Наконец, вид --- программа на Си (которая, между прочим, зависит только от
SQLite3 и ZeroMQ), под названием m2sh. Она предоставляет своеобразный интерфейс
в виде командной строки, который позволяет конфигурировать сервер, изменяя
модель. С помощью него можно генерировать конфигурации, изменять их,
просматривать и т.п.

Но самое главное --- \emph{вы можете написать свой скрипт}. Не нужно ждать,
пока разработчик Mongrel2 соизволит написать парсер для конфигурационного
файла, который поддерживал бы ваш любимый язык. Всё гораздо проще --- есть
SQLite3 база с простой схемой, а также пример работы с ней на Питоне и Си.
Вперёд и с песней!

Одним словом --- неограниченные возможности для автоматизации.

\section{Как использовать мануал}

Мануал писался так, чтобы вам было нескучно его читать. Так что, возможно,
стоит действительно его \emph{прочесть}.

Да, да, знаю... У кого в наши дни есть время читать и учить что-то? Вы хотите
немедленно приступить к решению проблем. Нет времени на слова.

Вы когда-нибудь задавались вопросом --- возможно ваше нежелание читать и учить
является причиной того, что вы частенько оказываетесь в затруднительном положении?

Да, есть над чем подумать.

Я всё же рекомендую, чтобы вы прочитали каждую страницу этого документа и
выполнили все команды. Даже если вы думаете, что вам что-то не пригодится,
потому что вы не программист, или вы не сисадмин, вам всё равно стоит это
изучить. Сделав это у вас сложится более полная и ясная картина, что облегчит
вам жизнь в будущем.
